::  Mapping of opcodes of SIMD instructions with
::  no immediate arguments to $instructions.
::
/-  *wasm
|=  op=@
~+
|^
^-  (unit instruction)
=;  =(unit instr-vec)
  ?~  unit  ~
  [%vec u.unit]
?+  op    ~
  %14   `[%swizzle ~]
  %98   `[%popcnt ~] 
  %77   `[%not ~]
  %78   `[%and ~]
  %79   `[%andnot ~]
  %80   `[%or ~]
  %81   `[%xor ~]
  %82   `[%bitselect ~]
  %83   `[%any-true ~]
  %130  `[%q15mul-r-sat ~]
  %186  `[%dot ~] 
  %94   `[%demote ~]
  %95   `[%promote ~]
::
  ?(%106 %148)  `(nearest op)
  ?(%227 %239)  `(sqrt op)
  ?(%231 %243)  `(div op)
  ?(%234 %246)  `(pmin op)
  ?(%235 %247)  `(pmax op)
  ?(%123 %155)  `(avgr op)
  ?(%103 %116)  `(ceil op) 
  ?(%104 %117)  `(floor op)
::
  ?(%99 %131 %163 %195)   `(all-true op)
  ?(%100 %132 %164 %196)  `(bitmask op) 
  ?(%101 %102 %133 %134)  `(narrow op)
  ?(%107 %139 %171 %203)  `(shl op)
  ?(%124 %125 %126 %127)  `(extadd op) 
  ?(%250 %251 %254 %255)  `(convert op)
::
  ?(%149 %181 %213 %230 %242)       `(mul op) 
  ?(%15 %16 %17 %18 %19 %20)        `(splat op)
  ?(%35 %45 %55 %214 %65 %71)       `(eq op)
  ?(%36 %46 %56 %215 %66 %72)       `(ne op)
  ?(%96 %128 %160 %192 %224 %236)   `(abs op)
  ?(%97 %129 %161 %193 %225 %237)   `(neg op) 
  ?(%105 %122 %248 %249 %252 %253)  `(trunc op) 
::
  ?(%37 %38 %47 %48 %57 %58 %216 %67 %73)  `(lt op) 
  ?(%39 %40 %49 %50 %59 %60 %217 %68 %74)  `(gt op)
  ?(%41 %42 %51 %52 %61 %62 %218 %69 %75)  `(le op)
  ?(%43 %44 %53 %54 %63 %64 %219 %70 %76)  `(ge op)
::
  ?(%108 %109 %140 %141 %172 %173 %204 %205)  `(shr op) 
  ?(%118 %119 %150 %151 %182 %183 %232 %244)  `(min op)
  ?(%120 %121 %152 %153 %184 %185 %233 %245)  `(max op)
::
  ?(%110 %111 %112 %142 %143 %144 %174 %206 %228 %240)  `(add op) 
  ?(%113 %114 %115 %145 %146 %147 %177 %209 %229 %241)  `(sub op) 
::
  ?(%135 %136 %137 %138 %167 %168 %169 %170 %199 %200 %201 %202)  `(extend op) 
  ?(%156 %157 %158 %159 %188 %189 %190 %191 %220 %221 %222 %223)  `(extmul op)
==
::
++  nearest
  |=  op=?(%106 %148)
  ^-  instr-vec
  :-  %nearest
  ?-  op
    %106  %f32
    %148  %f64
  ==
::
++  sqrt
  |=  op=?(%227 %239)
  ^-  instr-vec
  :-  %sqrt
  ?-  op
    %227  %f32
    %239  %f64
  ==
::
++  div
  |=  op=?(%231 %243)
  ^-  instr-vec
  :-  %div
  ?-  op
    %231  %f32
    %243  %f64
  ==
::
++  pmin
  |=  op=?(%234 %246)
  ^-  instr-vec
  :-  %pmin
  ?-  op
    %234  %f32
    %246  %f64
  ==
::
++  pmax
  |=  op=?(%235 %247)
  ^-  instr-vec
  :-  %pmax
  ?-  op
    %235  %f32
    %247  %f64
  ==
::
++  avgr
  |=  op=?(%123 %155)
  ^-  instr-vec
  :-  %avgr
  :_  %u
  ?-  op
    %123  %i8
    %155  %i16
  ==
::
++  ceil
  |=  op=?(%103 %116)
  ^-  instr-vec
  :-  %ceil
  ?-  op
    %103  %f32
    %116  %f64
  ==
::
++  floor
  |=  op=?(%104 %117)
  ^-  instr-vec
  :-  %floor
  ?-  op
    %104  %f32
    %117  %f64
  ==
::
++  all-true
  |=  op=?(%99 %131 %163 %195)
  ^-  instr-vec
  :-  %all-true
  ?-  op
    %99   %i8
    %131  %i16
    %163  %i32
    %195  %i64
  ==
::
++  bitmask 
  |=  op=?(%100 %132 %164 %196)
  ^-  instr-vec
  :-  %bitmask
  ?-  op
    %100  %i8
    %132  %i16
    %164  %i32
    %196  %i64
  ==
::
++  narrow
  |=  op=?(%101 %102 %133 %134)
  ^-  instr-vec
  :-  %narrow
  ?-  op
    %101  
    %102
    %133
    %134
  ==
::
++  shl
  |=  op=?(%107 %139 %171 %203)
  ^-  instr-vec
  :-
  ?-  op
  ==
::
++  extadd 
  |=  op=?(%124 %125 %126 %127)
  ^-  instr-vec
  :-
  ?-  op
  ==
::
++  convert
  |=  op=?(%250 %251 %254 %255)
  ^-  instr-vec
  :-
  ?-  op
  ==
::
--